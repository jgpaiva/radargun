package org.radargun.keygenerator;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * The key generator interface. The keys are generated randomly depending of the topology of the cluster and if it is
 * contention free or not.
 *
 * This interface also includes a constructor to build instances of this interface
 *
 * @author Pedro Ruivo
 * @since 1.1
 */
public interface KeyGenerator {

   /**
    * returns a random generated key
    *
    * @return  a random generated key     
    */
   String getRandomKey();

   /**
    * returns a random value to set to a key. the size of the value is specify in the construction of the instance
    *
    * @return  a random value to set to a key
    */
   String getRandomValue();

   /**
    * returns the bucket prefix
    *
    * @return  the bucket prefix
    */
   String getBucketPrefix();

   /**
    * returns all the possible keys to be generated by this component
    *
    * @return  all the possible keys to be generated by this component
    */
   Collection<String> getAllKeys();

   /**
    * returns the warmup iterator for the warmup phase
    *
    * @return  the warmup iterator for the warmup phase  
    */
   WarmupIterator getWarmupIterator();

   /**
    * The key generator factory. It can construct WarmupIterators for warmup phase or KeyGenerators for the benchmark
    * phase
    */
   public static class KeyGeneratorFactory {

      private static final Log log = LogFactory.getLog(KeyGeneratorFactory.class);

      private int numberOfNodes;
      private int numberOfThreads;
      private int numberOfKeys;
      private int valueSize;
      private boolean shared;
      private String bucketPrefix;

      public KeyGeneratorFactory(int numberOfNodes, int numberOfThreads, int numberOfKeys, int valueSize,
                                 boolean shared, String bucketPrefix) {
         this.numberOfNodes = numberOfNodes;
         this.numberOfThreads = numberOfThreads;
         this.numberOfKeys = numberOfKeys;
         this.valueSize = valueSize;
         this.shared = shared;
         this.bucketPrefix = bucketPrefix;
      }

      /**
       * Note: should be invoked in the beginning of the benchmark. 
       *
       * this method checks the new values with the previously values set in the warmup phase. It updates and logs
       * a warning if the values mismatch.
       *
       * @param numberOfNodes    the number of nodes
       * @param numberOfThreads  the number of threads
       * @param numberOfKeys     the number of keys
       * @param valueSize        the value size of each key
       * @param shared           if contention can happen or not
       * @param bucketPrefix     the bucket prefix
       */
      public final void checkAndUpdate(int numberOfNodes, int numberOfThreads, int numberOfKeys, int valueSize,
                                       boolean shared, String bucketPrefix) {
         if (this.numberOfNodes != numberOfNodes) {
            logMismatch("Number of Nodes", this.numberOfNodes, numberOfNodes);
            this.numberOfNodes = numberOfNodes;
         }
         if (this.numberOfThreads != numberOfThreads) {
            logMismatch("Number of Threads", this.numberOfThreads, numberOfThreads);
            this.numberOfThreads = numberOfThreads;
         }
         if (this.valueSize != valueSize) {
            logMismatch("Value Size", this.valueSize, valueSize);
            this.valueSize = valueSize;
         }
         if (this.numberOfKeys != numberOfKeys) {
            logMismatch("Number of Keys", this.numberOfKeys, numberOfKeys);
            this.numberOfKeys = numberOfKeys;
         }
         if (this.shared != shared) {
            logMismatch("Shared", this.shared, shared);
            this.shared = shared;
         }
         if ((this.bucketPrefix != null && !this.bucketPrefix.equals(bucketPrefix)) ||
               (this.bucketPrefix == null && bucketPrefix != null)) {
            logMismatch("Bucket Prefix", this.bucketPrefix, bucketPrefix);
            this.bucketPrefix = bucketPrefix;
         }
      }

      private void logMismatch(String name, Object warmup, Object benchmark) {
         log.warn("*** WARNING: " + name + " changed between the warmup and the benchmark! Warmup value is " +
                        warmup + " and the benchmark value is " + benchmark);
      }

      /**
       * returns a list of warmup iterators for the warmup phase. this constructor is used for multi-master schemes
       *
       *
       * @param nodeIdx             the node/slave index
       * @param ignoreBucketPrefix  true if the bucket prefix is ignored by the cache wrapper
       * @return                    a list of warmup iterators for the warmup phase
       */
      public final List<WarmupIterator> constructForWarmup(int nodeIdx, boolean ignoreBucketPrefix) {
         List<WarmupIterator> result = new ArrayList<WarmupIterator>(numberOfThreads);
         if (shared) {
            int remainder = numberOfKeys % numberOfNodes;
            int keysPerNode = numberOfKeys / numberOfNodes;
            int startIdx = nodeIdx * keysPerNode;
            int endIdx = startIdx + keysPerNode;

            createShared(startIdx, endIdx, result, ignoreBucketPrefix);

            if (nodeIdx == 0 && remainder > 0) {
               startIdx = nodeIdx * numberOfNodes;
               endIdx = startIdx + remainder;
               createShared(startIdx, endIdx, result, ignoreBucketPrefix);
            }
         } else {
            int keysPerNode = numberOfKeys / numberOfNodes;
            int keysPerThread = Math.max(1, keysPerNode / numberOfThreads);

            for (int threadIdx = 0; threadIdx < numberOfThreads; ++threadIdx) {
               result.add(new PrivateKeyGenerator(nodeIdx, threadIdx, keysPerThread, valueSize, bucketPrefix).getWarmupIterator());
            }

            if (nodeIdx == 0) {
               int totalKeysCreated = keysPerThread * numberOfThreads * numberOfNodes;
               int remainder = numberOfKeys - totalKeysCreated;

               if (remainder > 0) {
                  createShared(remainder, result, ignoreBucketPrefix);
               }
            }
         }
         return result;
      }

      /**
       * returns a list of warmup iterators for the warmup phase. this constructor is used for single-master schemes
       *
       *
       * @param isMaster            true if this node/slave is the only master
       * @param ignoreBucketPrefix  true if the bucket prefix is ignored by the cache wrapper
       * @return                    a list of warmup iterators for the warmup phase
       */
      public final List<WarmupIterator> constructForWarmup(boolean isMaster, boolean ignoreBucketPrefix) {
         List<WarmupIterator> result = new ArrayList<WarmupIterator>(numberOfThreads);
         if (!isMaster) {
            return result;
         }
         if (shared) {
            //populate everything            
            createShared(numberOfKeys, result, ignoreBucketPrefix);
         } else {
            int keysPerNode = numberOfKeys / numberOfNodes;
            int keysPerThread = Math.max(1, keysPerNode / numberOfThreads);

            for (int nodeIdx = 0; nodeIdx < numberOfNodes; ++nodeIdx) {
               for (int threadIdx = 0; threadIdx < numberOfThreads; ++threadIdx) {
                  result.add(new PrivateKeyGenerator(nodeIdx, threadIdx, keysPerThread, valueSize, bucketPrefix).getWarmupIterator());
               }
            }

            int totalKeysCreated = keysPerThread * numberOfThreads * numberOfNodes;
            int remainder = numberOfKeys - totalKeysCreated;

            if (remainder > 0) {
               createShared(remainder, result, ignoreBucketPrefix);
            }
         }
         return result;
      }

      /**
       * returns a KeyGenerator for the specific thread in the specific node
       * @param nodeIdx    the node/slave index 
       * @param threadIx   the thread index
       * @return           a KeyGenerator for the specific thread in the specific node
       */
      public final KeyGenerator constructForBenchmark(int nodeIdx, int threadIx) {
         if (shared) {
            return new SharedKeyGenerator(threadIx, numberOfKeys, valueSize, bucketPrefix);
         } else {
            int keysPerNode = numberOfKeys / numberOfNodes;
            int keysPerThread = Math.max(1, keysPerNode / numberOfThreads);
            return new PrivateKeyGenerator(nodeIdx, threadIx, keysPerThread, valueSize, bucketPrefix);
         }
      }

      private void createShared(int startIdx, int endIdx, List<WarmupIterator> result, boolean ignoreBucketPrefix) {
         if (ignoreBucketPrefix) {
            result.add(new SharedKeyGenerator(0, startIdx, endIdx, valueSize, bucketPrefix).getWarmupIterator());
         } else {
            for (int threadIdx = 0; threadIdx < numberOfThreads; ++threadIdx) {
               result.add(new SharedKeyGenerator(threadIdx, startIdx, endIdx, valueSize, bucketPrefix).getWarmupIterator());
            }
         }
      }

      private void createShared(int numberOfKeys, List<WarmupIterator> result, boolean ignoreBucketPrefix) {
         if (ignoreBucketPrefix) {
            result.add(new SharedKeyGenerator(0, numberOfKeys, valueSize, bucketPrefix).getWarmupIterator());
         } else {
            for (int threadIdx = 0; threadIdx < numberOfThreads; ++threadIdx) {
               result.add(new SharedKeyGenerator(threadIdx, numberOfKeys, valueSize, bucketPrefix).getWarmupIterator());
            }
         }
      }
   }
}
